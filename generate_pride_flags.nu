let endpoint = "https://pride-flag.dev/api/flags";

let flags = curl $endpoint -so - | from json | uniq-by name;

$flags | each  {|flag| 
    $"pub fn ($flag.name | str downcase | str replace -a ' ' '_')\(\) -> impl Shader<FragOne> {
    uniform_segments\(
        vec![
            ($flag | get colors | get hexCode | each {|colors| 
                ($colors | each {|color| 
                    let color = $color | str upcase;
                    if ($color | str length) < 6 {
                        $color | split chars | reduce --fold "" {|it, acc| 
                            $"($acc)($it)(if $it != '#' { $it } else { "" })"
                        }
                    } else {
                        $color
                    } | str replace '#' '0x'
                })
            } | reduce --fold "" {|it, acc|  
                $"($acc)hex\(($it)\),\n\t\t"
            })
        ]
    \)
}"
} | reduce {|it, acc| 
    $"($acc)\n\n($it)"
} | $"//! Pride flag shaders.
//!
//! This file was generated by generate_pride_flags.nu
//! If there is weird shit in here it's not my fault. Just making that clear
#![allow\(unused\)]

use super::{hex, uniform_segments, ShaderExt2};
use shark::shader::{FragOne, Shader};
use palette::LinSrgb;

($in)"
| $"
($in)

pub\(super\) const FLAGS: &[fn\(\) -> Box<dyn Shader<FragOne, Output = LinSrgb<f64>>>] = &[
($flags | each {|flag| 
    let name = $flag.name | str downcase | str replace -a ' ' '_'
    $"{
        fn ($name)_wrapped\(\) -> Box<dyn Shader<FragOne, Output = LinSrgb<f64>>> {
            Box::new\(($name)\(\).to_linsrgb\(\)\)
        }
        ($name)_wrapped
    }"
} | reduce --fold "" {|it, acc|  
    $"($acc)\n($it),"
})
];
"
| rustfmt --emit stdout